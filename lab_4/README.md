# Звіт до роботи №6
## Тема: Робота з числовими даними в Python
## Мета: 
Навчитися працювати з числовими даними у мові програмування Python

---
### Виконання роботи

1. Підготовка до роботи:
    - Для зручності створили нову папку `lab_4` та новий файл Python з ім'ям `2_lab_numpy.ipynb`. 

1. Результати виконання завдань - "Робота з масивами за бібліотеки Numpy" - Визначення однорідного масиву:

```py
import numpy as np
lst = [ [3.4, 8.7, 9.9], 
        [1.1, -7.8, -0.7],
        [4.1, 12.3, 4.8] ]

A = np.array(lst, dtype=np.int8)
print(f"Отриманий масив має вигляд:\n{repr(A)}")
B = np.array(lst, dtype=np.float16)
print(f"Отриманий масив має вигляд:\n{repr(B)}")

homework("Згадуючи ООП, що робить функція repr?")
homework("У чому різниця між масивами A i B?")
```

```text
Отриманий масив має вигляд:
array([[ 3,  8,  9],
       [ 1, -7,  0],
       [ 4, 12,  4]], dtype=int8)
Отриманий масив має вигляд:
array([[ 3.4,  8.7,  9.9],
       [ 1.1, -7.8, -0.7],
       [ 4.1, 12.3,  4.8]], dtype=float16)

>>>>> Згадуючи ООП, що робить функція repr? 


>>>>> У чому різниця між масивами A i B? 
```

- Згадуючи ООП, що робить функція repr?

Функція repr() є вбудованою функцією у мові програмування Python, яка призначена для представлення об'єкта у вигляді рядка (string representation).

- У чому різниця між масивами A i B?

Різниця між масивами полягає в типах даних елементів. Всі елементи в масиві A будуть приведені до типу np.int8, що означає 8-бітні цілі числа. Всі елементи в масиві B будуть приведені до типу np.float16, що означає 16-бітні числа з плаваючою комою.


1. Результати виконання завдання - "Задаємо свій тип даних":

```py
dt = np.dtype([('name', np.compat.unicode, 20), ('mark', np.int8)])
arr = [
    ("Bohdan", 4), 
    ("Marta", 5),
    ("Noname", 0)
    ]
C = np.array(arr, dtype=dt)
print(f"Отриманий масив має вигляд:\n{C}")
print(f"Доступитись до певної колонки тепер можна за її іменем: {C['mark']}")

homework("Як вивести всі імена присутні в даному масиві?")
print(f"Всі імена в даному масиві:\n{C['name']}")
```

```text
Отриманий масив має вигляд:
[('Bohdan', 4) ('Marta', 5) ('Noname', 0)]
Доступитись до певної колонки тепер можна за її іменем: [4 5 0]

>>>>> Як вивести всі імена присутні в даному масиві? 

Всі імена в даному масиві:
['Bohdan' 'Marta' 'Noname']
```

    1. Результати виконання завдань - "Метод arange - генерує послідовність чисел з певним кроком у заданому інтервалі":

```py
start = 5
size_of_vec = 100
x = range(size_of_vec)
a = np.arange(size_of_vec)
print(f"Масив згенерований простим range: {x[0:5]} та методом arange: {a[0:5]}")
homework("Виведіть весь діапазон чисел.")
print(a, "\n")

a = np.arange(start, size_of_vec)
print(f"Можемо задавати початок генерації вектора, перший елемент: {a[0]}")
homework("Виведіть останній діапазон в згенерованому масиві.")
print(a, "\n")

x = range(start, size_of_vec)
print("Те саме але з вбудованою функцією range:", x)
print("Власне вивід значень:", list(x)[0], )
homework("Виведіть якесь число з середини діапазону.")
print(a[36], "\n")

# дробові числа
x = np.arange(10.4)
print("Будем мати:", x)
# крок
x = np.arange(0.5, 4, 0.5)
print("З кроком 0.5:", x)
# Заокруглення
x = np.arange(0.04, 1.84, 0.08)
print("З кроком 0.08:", x, "\n Зерніть увагу на заокруглення")
homework("Згенеруйте значення де крок буде мати чотири нулі після коми, яким буде результат?")
x = np.arange(0.0, 0.0001, 0.00001)
print(x, "\n")
y = x * 2.5
print("Після перемноження:", y)
homework("Піднесіть отримане число до степеня та поділіть на 0.4 - Яким буде результат?")
y = y*y/0.4
print(y, "\n")
```

```text
Масив згенерований простим range: range(0, 5) та методом arange: [0 1 2 3 4]

>>>>> Виведіть весь діапазон чисел. 

[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71
 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
 96 97 98 99] 

Можемо задавати початок генерації вектора, перший елемент: 5

>>>>> Виведіть останній діапазон в згенерованому масиві. 

[ 5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52
 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76
 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99] 

Те саме але з вбудованою функцією range: range(5, 100)
Власне вивід значень: 5

>>>>> Виведіть якесь число з середини діапазону. 

41 

Будем мати: [ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]
З кроком 0.5: [0.5 1.  1.5 2.  2.5 3.  3.5]
З кроком 0.08: [0.04 0.12 0.2  0.28 0.36 0.44 0.52 0.6  0.68 0.76 0.84 0.92 1.   1.08
 1.16 1.24 1.32 1.4  1.48 1.56 1.64 1.72 1.8 ] 
 Зерніть увагу на заокруглення

>>>>> Згенеруйте значення де крок буде мати чотири нулі після коми, яким буде результат? 

[0.e+00 1.e-05 2.e-05 3.e-05 4.e-05 5.e-05 6.e-05 7.e-05 8.e-05 9.e-05] 

Після перемноження: [0.00e+00 2.50e-05 5.00e-05 7.50e-05 1.00e-04 1.25e-04 1.50e-04 1.75e-04
 2.00e-04 2.25e-04]

>>>>> Піднесіть отримане число до степеня та поділіть на 0.4 - Яким буде результат? 

[0.000000e+00 1.562500e-09 6.250000e-09 1.406250e-08 2.500000e-08
 3.906250e-08 5.625000e-08 7.656250e-08 1.000000e-07 1.265625e-07] 

 ```

1. Результати виконання завдань - "Метод linspace - генерує задану кількістю чисел у певному діапазоні, 50 чисел за замовчуванням":

``` py
a = np.linspace(start, size_of_vec)
print(f"Згенерували {len(a)} чисел в діапазоні {a[0]} до {a[-1]}")
#print(f"Власне числа: {a}")
homework("Виведіть кожне друге число згенерованого діапазону. Тут буде потрібен цикл :)")
print("Кожне друге число:")
for i in range(1, len(a), 2):
    print(a[i])

print("Можна зменшити кількість чисел до 5:")
a = np.linspace(start, size_of_vec, 5)
print(a)
homework("Збільшіть кількість чисел до 100. Виведіть перших та останніх 10.")
a = np.linspace(start, size_of_vec, 100)
print("Збільшена кількість чисел до 100:")
print("Перші 10 чисел:", a[:10])
print("Останні 10 чисел:", a[-10:])

print("""\nЯк бачимо перше та останнє значення завжди входять у згенерований діапазон. 
Відповідно при цьому вираховується крок.
Це можна змінити, виключивши останнє значення з визначення діапазону.
""")

print(np.linspace(start, size_of_vec, 5, endpoint=False))
homework("Спробуйте самі порахувати крок.")
linspace_values = np.linspace(start, size_of_vec, 5, endpoint=False)
step = (linspace_values[-1] - linspace_values[0]) / (len(linspace_values) - 1)

print(f"Значення: {linspace_values}")
print(f"Крок: {step}")

_, sp_1 = np.linspace(start, size_of_vec, 5, endpoint=True, retstep=True)
_, sp_2 = np.linspace(start, size_of_vec, 5, endpoint=False, retstep=True)
print(f"\nДля порівняння, ми можемо визначити крок автоматично, у нашому випадку це {sp_1} та {sp_2}")
homework("Чому маємо такий крок?")
```

```text
Згенерували 50 чисел в діапазоні 5.0 до 100.0

>>>>> Виведіть кожне друге число згенерованого діапазону. Тут буде потрібен цикл :) 

Кожне друге число:
6.938775510204081
10.816326530612244
14.693877551020408
18.57142857142857
22.448979591836736
26.3265306122449
30.20408163265306
34.08163265306122
37.95918367346939
41.83673469387755
45.714285714285715
49.59183673469388
53.46938775510204
57.3469387755102
61.224489795918366
65.10204081632654
68.9795918367347
72.85714285714286
76.73469387755102
80.61224489795919
84.48979591836735
88.36734693877551
92.24489795918367
96.12244897959184
100.0
Можна зменшити кількість чисел до 5:
[  5.    28.75  52.5   76.25 100.  ]

>>>>> Збільшіть кількість чисел до 100. Виведіть перших та останніх 10. 

Збільшена кількість чисел до 100:
Перші 10 чисел: [ 5.          5.95959596  6.91919192  7.87878788  8.83838384  9.7979798
 10.75757576 11.71717172 12.67676768 13.63636364]
Останні 10 чисел: [ 91.36363636  92.32323232  93.28282828  94.24242424  95.2020202
  96.16161616  97.12121212  98.08080808  99.04040404 100.        ]

Як бачимо перше та останнє значення завжди входять у згенерований діапазон. 
Відповідно при цьому вираховується крок.
Це можна змінити, виключивши останнє значення з визначення діапазону.

[ 5. 24. 43. 62. 81.]

>>>>> Спробуйте самі порахувати крок. 

Значення: [ 5. 24. 43. 62. 81.]
Крок: 19.0

Для порівняння, ми можемо визначити крок автоматично, у нашому випадку це 23.75 та 19.0

>>>>> Чому маємо такий крок? 
```

- Чому маємо такий крок?

У коді використовується параметр retstep=True у функції np.linspace. Цей параметр вказує функції повернути крок (різницю між сусідніми елементами) разом із згенерованим масивом значень.
У випадку з sp_1, де використовується endpoint=True (за замовчуванням), крок розраховується, як різниця між останнім та першим значеннями, поділена на кількість кроків між ними.
У випадку з sp_2, де використовується endpoint=False, крок розраховується, як різниця між першим та другим значеннями, оскільки останнє значення не включається (згідно з endpoint=False).

1. Результати виконання завдань - "Типи масивів/векторів":

```py
examples = {
    'Скаляр': np.array(1), 
    'Вектор Рядок': np.array([1, 2, 3]), 
    'Вектор Стовпець': np.array([[1], [2], [3]]), 
    'Матриця': np.array([[1, 2],[3, 4], [5, 6]]),
    'Багатовимірна Матриця': np.array([ [[111, 112], [121, 122]],
                                        [[211, 212], [221, 222]],
                                        [[311, 312], [321, 322]] ])
    }
for key in examples:
    print(f"Розглядаємо приклад з {key}. \nЗначення x буде: \n", examples[key])
    print(f"Тип {key} x: ", type(examples[key]))
    print(f"Розмірність/вимір {key} x:", np.ndim(examples[key]))
    print(f"Форма {key} x: ", examples[key].shape)
    print(f"Кількість елементів х: {np.size(examples[key])}")
    print("-=-"*10)

homework("""Як Ви думаєте чому маємо такий результат для функції np.ndim (Розмірність/вимір/dimension).
Чому значення для векторів та матриць однакове та не співпдає з значенням shape?
Задайте власні вектори з різними числами.""")

custom_row = np.array([10, 20, 30])  
custom_column = np.array([[5], [8], [12]])  

custom_examples = {
    'Рядок': custom_row,
    'Стовпець': custom_column
}

for key in custom_examples:
    print(f"Розглядаємо приклад з {key}. \nЗначення x буде: \n", custom_examples[key])
    print(f"Тип {key} x: ", type(custom_examples[key]))
    print(f"Розмірність/вимір {key} x:", np.ndim(custom_examples[key]))
    print(f"Форма {key} x: ", custom_examples[key].shape)
    print(f"Кількість елементів х: {np.size(custom_examples[key])}")
    print("-=-"*10)
```

```text
Розглядаємо приклад з Скаляр. 
Значення x буде: 
 1
Тип Скаляр x:  <class 'numpy.ndarray'>
Розмірність/вимір Скаляр x: 0
Форма Скаляр x:  ()
Кількість елементів х: 1
-=--=--=--=--=--=--=--=--=--=-
Розглядаємо приклад з Вектор Рядок. 
Значення x буде: 
 [1 2 3]
Тип Вектор Рядок x:  <class 'numpy.ndarray'>
Розмірність/вимір Вектор Рядок x: 1
Форма Вектор Рядок x:  (3,)
Кількість елементів х: 3
-=--=--=--=--=--=--=--=--=--=-
Розглядаємо приклад з Вектор Стовпець. 
Значення x буде: 
 [[1]
 [2]
 [3]]
Тип Вектор Стовпець x:  <class 'numpy.ndarray'>
Розмірність/вимір Вектор Стовпець x: 2
Форма Вектор Стовпець x:  (3, 1)
Кількість елементів х: 3
-=--=--=--=--=--=--=--=--=--=-
Розглядаємо приклад з Матриця. 
Значення x буде: 
 [[1 2]
 [3 4]
 [5 6]]
Тип Матриця x:  <class 'numpy.ndarray'>
Розмірність/вимір Матриця x: 2
Форма Матриця x:  (3, 2)
Кількість елементів х: 6
-=--=--=--=--=--=--=--=--=--=-
Розглядаємо приклад з Багатовимірна Матриця. 
Значення x буде: 
 [[[111 112]
  [121 122]]

 [[211 212]
  [221 222]]

 [[311 312]
  [321 322]]]
Тип Багатовимірна Матриця x:  <class 'numpy.ndarray'>
Розмірність/вимір Багатовимірна Матриця x: 3
Форма Багатовимірна Матриця x:  (3, 2, 2)
Кількість елементів х: 12
-=--=--=--=--=--=--=--=--=--=-

>>>>> Як Ви думаєте чому маємо такий результат для функції np.ndim (Розмірність/вимір/dimension).
Чому значення для векторів та матриць однакове та не співпдає з значенням shape?
Задайте власні вектори з різними числами. 

Розглядаємо приклад з Вектор Рядок. 
Значення x буде: 
 [10 20 30]
Тип Вектор Рядок x:  <class 'numpy.ndarray'>
Розмірність/вимір Вектор Рядок x: 1
Форма Вектор Рядок x:  (3,)
Кількість елементів х: 3
-=--=--=--=--=--=--=--=--=--=-
Розглядаємо приклад з Вектор Стовпець. 
Значення x буде: 
 [[ 5]
 [ 8]
 [12]]
Тип Вектор Стовпець x:  <class 'numpy.ndarray'>
Розмірність/вимір Вектор Стовпець x: 2
Форма Вектор Стовпець x:  (3, 1)
Кількість елементів х: 3
-=--=--=--=--=--=--=--=--=--=-
```

- Як Ви думаєте чому маємо такий результат для функції np.ndim (Розмірність/вимір/dimension).

Оскільки функція np.ndim повертає кількість вимірів (розмірність) масиву, але враховує не тільки розмірність масиву, але й форму.

- Чому значення для векторів та матриць однакове та не співпдає з значенням shape?

Через те, що вектор визначається лише кількістю його розмірностей, а форма враховує кількість елементів у кожному розмірі.

1. Результати виконання завдань - "Багатовимірні масиви, розуміння вимірів":

```py
examples = {
    '5 рядків': np.array([[1], [2], [3], [4], [5]]), 
    '5 стовпців': np.array([[1, 2, 3, 4, 5]]),
    '5 елементів': np.array([[[1, 2, 3, 4, 5]]])
    }
for a in examples:
    print(f"Для {a} маємо shape: \n{examples[a].shape} \nта вигляд: \n{examples[a]}")

homework(f"Створіть власні масиви з різною кількістю елементів та використайте метод shape для визначення їх вимірів.")
array_1 = np.array([[1, 2, 3], [4, 5, 6]]) 
array_2 = np.array([1, 2, 3, 4, 5])          

custom_examples = {
    '2D масив': array_1,
    '1D масив': array_2,
}

for a in custom_examples:
    print(f"Для {a} маємо shape: \n{custom_examples[a].shape} \nта вигляд: \n{custom_examples[a]}\n")
```

```text
Для 5 рядків маємо shape: 
(5, 1) 
та вигляд: 
[[1]
 [2]
 [3]
 [4]
 [5]]
Для 5 стовпців маємо shape: 
(1, 5) 
та вигляд: 
[[1 2 3 4 5]]
Для 5 елементів маємо shape: 
(1, 1, 5) 
та вигляд: 
[[[1 2 3 4 5]]]

>>>>> Створіть власні масиви з різною кількістю елементів та використайте метод shape для визначення їх вимірів. 

Для 2D масив маємо shape: 
(2, 3) 
та вигляд: 
[[1 2 3]
 [4 5 6]]

Для 1D масив маємо shape: 
(5,) 
та вигляд: 
[1 2 3 4 5]
```

1. Результати виконання завдань - "Indexing and Slicing":

```py
F = np.array([1, 1, 2, 3, 5, 8, 13, 21])
print(f"""Масив: {F}
Виміри: {F.shape}
Памятаємо, що номерація масивів відбувається з 0.
Тому перший елемент масиву:\n {F[0]}
Другий:\n {F[1]}
Останній, {len(F)}: \n {F[7]}""")

print(f"""Можемо скористатись відємними індексами якщо хочемо доступитись до елементів з кінця масиву.
Але номерація вже з 1.
Тому останній елемент:\n {F[-1]}
Передостанній:\n {F[-2]}""")

homework("Попрактикуйтесь доступатись до елементів, виведіть декілька елементів різними способами.")
print(f"""Третій:\n {F[2]} 
Шостий:\n {F[5]} 
Сьомий:\n {F[-2]} 
Шостий:\n {F[-3]}""")
```

```text
Масив: [ 1  1  2  3  5  8 13 21]
Виміри: (8,)
Памятаємо, що номерація масивів відбувається з 0.
Тому перший елемент масиву:
 1
Другий:
 1
Останній, 8: 
 21
Можемо скористатись відємними індексами якщо хочемо доступитись до елементів з кінця масиву.
Але номерація вже з 1.
Тому останній елемент:
 21
Передостанній:
 13

>>>>> Попрактикуйтесь доступатись до елементів, виведіть декілька елементів різними способами. 

Третій:
 2 
Шостий:
 8 
Сьомий:
 13 
Шостий:
 8
```


```py
A = np.array([ [3.4, 8.7, 9.9], 
               [1.1, -7.8, -0.7],
               [4.1, 12.3, 4.8],
               [7.0, -3.9, 5.1]])

print(f"""Масив:
{A}
Виміри: {A.shape}
Принцип номерації такий самий, ТІЛЬКИ:
Якщо задати одне значення то візьметься цілий рядок:
    Перший рядок: {A[0]}
    Останній рядок: {A[-1]}
Для того щоб взяти цілий стовпець (символ : вказує взяти всі елементи): 
    Перший стовпець: {A[:,0]}
    Останній стовпець: {A[:,-1]}
Потрібно задавати два значення для отримання конкретного елемента: 
    Перший елемент: {A[0][0]} або {A[0, 0]}
    Останній елемент: {A[3][2]} або {A[-1][-1]} або {A[3, -1]}
""")

homework("Попрактикуйтесь в доступі до багатовимірного масиву, виведіть елементів які належать діагоналі.")
print("Елементи по діагоналі:")
for i in range(min(A.shape[0], A.shape[1])):
    print(A[i, i])
```

```text
Масив:
[[ 3.4  8.7  9.9]
 [ 1.1 -7.8 -0.7]
 [ 4.1 12.3  4.8]
 [ 7.  -3.9  5.1]]
Виміри: (4, 3)
Принцип номерації такий самий, ТІЛЬКИ:
Якщо задати одне значення то візьметься цілий рядок:
    Перший рядок: [3.4 8.7 9.9]
    Останній рядок: [ 7.  -3.9  5.1]
Для того щоб взяти цілий стовпець (символ : вказує взяти всі елементи): 
    Перший стовпець: [3.4 1.1 4.1 7. ]
    Останній стовпець: [ 9.9 -0.7  4.8  5.1]
Потрібно задавати два значення для отримання конкретного елемента: 
    Перший елемент: 3.4 або 3.4
    Останній елемент: 5.1 або 5.1 або 5.1


>>>>> Попрактикуйтесь в доступі до багатовимірного масиву, виведіть елементів які належать діагоналі. 

Елементи по діагоналі:
3.4
-7.8
4.8
```

```py
S = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

print(f"""Масив:
{S}
Виміри: {S.shape}
Беремо декілька елементів: {S[2:5]}
Всі елементи до заданого: {S[:4]}
Всі елементи від заданого до кінця: {S[6:]}
Всі елементи: {S[:]}
""")
homework("Попрактикуйтесь у витягуванні елементів, візьміть 4 значення з кінця масиву.")
print(f"""Останні 4 елементи масиву: {S[-4:]}""")
```

```text
Масив:
[0 1 2 3 4 5 6 7 8 9]
Виміри: (10,)
Беремо декілька елементів: [2 3 4]
Всі елементи до заданого: [0 1 2 3]
Всі елементи від заданого до кінця: [6 7 8 9]
Всі елементи: [0 1 2 3 4 5 6 7 8 9]


>>>>> Попрактикуйтесь у витягуванні елементів, візьміть 4 значення з кінця масиву. 

Останні 4 елементи масиву: [6 7 8 9]
```

```py
A = np.array([
[11, 12, 13, 14, 15],
[21, 22, 23, 24, 25],
[31, 32, 33, 34, 35],
[41, 42, 43, 44, 45],
[51, 52, 53, 54, 55]])

print(f"""Масив:
{A}
Виміри: {A.shape}
Беремо декілька рядків: 
{A[0:2]}
Два перші стовпці: 
{A[:, 0:2]}
Два останні рядки:
{A[3:, :]}
Беремо підматрицю (нижні елементи): 
{A[-3:, -3:]}
""")
homework("Попрактикуйтесь у витягуванні елементів, візьміть матрицю 2х2 з нижнього та верхнього кутка матриці А.")
print(f"""Матриця 2х2 нижнього та верхнього кутка матриці А: \n{A[-2:, 0:2]} \n {A[0:2, -2:]}""")
```

```text
Масив:
[[11 12 13 14 15]
 [21 22 23 24 25]
 [31 32 33 34 35]
 [41 42 43 44 45]
 [51 52 53 54 55]]
Виміри: (5, 5)
Беремо декілька рядків: 
[[11 12 13 14 15]
 [21 22 23 24 25]]
Два перші стовпці: 
[[11 12]
 [21 22]
 [31 32]
 [41 42]
 [51 52]]
Два останні рядки:
[[41 42 43 44 45]
 [51 52 53 54 55]]
Беремо підматрицю (нижні елементи): 
[[33 34 35]
 [43 44 45]
 [53 54 55]]


>>>>> Попрактикуйтесь у витягуванні елементів, візьміть матрицю 2х2 з нижнього та верхнього кутка матриці А. 

Матриця 2х2 нижнього та верхнього кутка матриці А: 
[[41 42]
 [51 52]] 
 [[14 15]
 [24 25]]
```

```py
A = np.arange(28).reshape(4, 7)

print(f"""Масив:
{A}
Виміри: {A.shape}
Беремо кожен дугий елемент першого рядка: 
{A[0, ::2]}
Беремо кожен третій елемент першого рядка: 
{A[0, ::3]}
Кожен другий елемент в кожномуу другому рядку: 
{A[::2, ::2]}
Останні три елементи в кожному другому рядку:
{A[::2, 4:]}
Можна повнісню змінити порядок елементів (дзерально обернемо):
{A[::-1, ::-1]}
""")

homework("Попрактикуйтесь у витягуванні елементів, будь-яка робоча комбінація.")
print(f"""Елемент: {A[2, 3]} 
Підмасив:\n{A[1:3, 4:7]}""")
```

```text
Масив:
[[ 0  1  2  3  4  5  6]
 [ 7  8  9 10 11 12 13]
 [14 15 16 17 18 19 20]
 [21 22 23 24 25 26 27]]
Виміри: (4, 7)
Беремо кожен дугий елемент першого рядка: 
[0 2 4 6]
Беремо кожен третій елемент першого рядка: 
[0 3 6]
Кожен другий елемент в кожномуу другому рядку: 
[[ 0  2  4  6]
 [14 16 18 20]]
Останні три елементи в кожному другому рядку:
[[ 4  5  6]
 [18 19 20]]
Можна повнісню змінити порядок елементів (дзерально обернемо):
[[27 26 25 24 23 22 21]
 [20 19 18 17 16 15 14]
 [13 12 11 10  9  8  7]
 [ 6  5  4  3  2  1  0]]


>>>>> Попрактикуйтесь у витягуванні елементів, будь-яка робоча комбінація. 

Елемент: 17 
Підмасив:
[[11 12 13]
 [18 19 20]]
```

```py
A = np.arange(50)
all_even = (A%2==0) # парні
complex = (A<30) & (A/5<2) 

print(f"""Спочатку потрібно створити умову за якою здійснювати вибірку.
Результат умови буде або {all_even[0]} для {A[0]} або {all_even[1]} для {A[1]}.
Після підставляння умови пошуку парних чисел в масив отримаємо:
{A[all_even]}
Або застосувавти більш комплексну умову з двох порінянь:
{A[complex]}""")

homework("Виведіть всі непарні числа з даного масиву.")
odd_numbers = A[~all_even & complex]

print("Всі непарні числа:")
print(odd_numbers)
```

```text
Спочатку потрібно створити умову за якою здійснювати вибірку.
Результат умови буде або True для 0 або False для 1.
Після підставляння умови пошуку парних чисел в масив отримаємо:
[ 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46
 48]
Або застосувавти більш комплексну умову з двох порінянь:
[0 1 2 3 4 5 6 7 8 9]

>>>>> Виведіть всі непарні числа з даного масиву. 

Всі непарні числа:
[1 3 5 7 9]
```

1. Результати виконання завдань - "Функції для створення матриць: ones, zeros, identity, eye, empty":

```py
o = np.ones(5)
z = np.zeros(5)
i = np.identity(5)
e = np.eye(5)
t = np.empty(5)

print(f"""
Всі елементи 1:
{o}
Всі елементи 0:
{z}
Матриця в якої діагональ всі 1:
{i}
Також, діагональ всі 1 (зменшимо вивід):
{e[:2, :2]}
Пуста матриця буде містити набір випадкових чисел які записані у память де був ініціалізований масив:
{t}
""")
```

```text
Всі елементи 1:
[1. 1. 1. 1. 1.]
Всі елементи 0:
[0. 0. 0. 0. 0.]
Матриця в якої діагональ всі 1:
[[1. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0.]
 [0. 0. 1. 0. 0.]
 [0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 1.]]
Також, діагональ всі 1 (зменшимо вивід):
[[1. 0.]
 [0. 1.]]
Пуста матриця буде містити набір випадкових чисел які записані у память де був ініціалізований масив:
[ 5. 24. 43. 62. 81.]
```

### Завдання 7:

1. Спробуйте визначити за якою формулою генеруються значення для методу `arange`. Спробуйте визначити формулу для методу `linspace`. Порівняйте формули, для яких випадків вони можуть застосовуватись?

- Метод `np.arange` генерує значення, використовуючи аргументи `start`, `stop` та (опційно) `step`. Значення утворюють арифметичну прогресію. Метод `np.linspace` генерує рівномірно розподілені значення у вказаному інтервалі. `np.arange` застосовується, коли необхідно вказати конкретний крок між значеннями, а `np.linspace` використовується, коли точно вказана кількість значень або рівномірний розподіл є ключовими.

### Завдання 8:

1. Створіть декілька простих Векторів та Матриць та виведіть їх розмірність. Виконайте арифметичні операції над створеними Векторам/Матрицями;

```py
a = np.arange(1, 6)  
b = np.arange(5, 10) 

matrix = np.arange(1, 13).reshape(3, 4) 

print("Розмірність вектора A:", a.shape)
print("Розмірність вектора B:", b.shape)
print("Розмірність матриці A:", matrix.shape)

result_sum = a + b
result_diff = b - a
result_product = a * b

print("\nРезультат додавання векторів:", result_sum)
print("Результат віднімання векторів:", result_diff)
print("Результат множення векторів:", result_product)

scalar = 2
result_matrix_product = matrix * scalar

print("\nМатриця A помножена на скаляр", scalar, ":\n", result_matrix_product)
```

Маємо наступний результат

```text
Розмірність вектора A: (5,)
Розмірність вектора B: (5,)
Розмірність матриці A: (3, 4)

Результат додавання векторів: [ 6  8 10 12 14]
Результат віднімання векторів: [4 4 4 4 4]
Результат множення векторів: [ 5 12 21 32 45]

Матриця A помножена на скаляр 2 :
 [[ 2  4  6  8]
 [10 12 14 16]
 [18 20 22 24]]
```

### Висновок:
- :question: Що зроблено в роботі :arrow_down: 

У цій роботі ми познайомилися із основами бібліотеки Numpy у мові програмування Python та навчилися нею користуватися 

- :question: Чи досягнуто мети роботи :arrow_down: 

Так, ми освоїли основні концепції бібліотеки Numpy у мові програмування Python та набули практичних навичок її використання.

- :question: Які нові знання отримано :arrow_down:

Я дізнався про основні можливості використання бібліотеки Numpy у Python.

- :question: Чи вдалось відповісти на всі питання задані в ході роботи :arrow_down:

Так, на всі питання були дані повноцінні відповіді.

- :question: Чи вдалося виконати всі завдання :arrow_down:

Так, всі завдання були опрацьовані та виконані відмінно (на думку Chatgpt:smile:).

- :question: Чи виникли складності у виконанні завдання :arrow_down:

Ні, виконання лабораторної роботи було безперешкодним, оскільки з допомогою Chatgpt в мене все вдавалось.

- :question: Чи подобається такий формат здачі роботи (Feedback) :arrow_down:

Так, це достатньо простий та добре структурований формат здачі завдання, у якому можна достатньо легко показати результати виконаних завдань.

- :question: Побажання для покращення (Suggestions) :arrow_down:

Немає!

---